## 库表设计规范
- 需要进行分表时，强烈推荐将分表数设置为10的幂，如100分表、10000分表等，同时分库数需要能被分表数整除，保证每个分库内都有相等数量的分表。
- varchar字段长度够用即可，单行长度上限为65535字符。
- 分表id生成禁止使用自增id，需要保证全局唯一，必须使用统一id生成服务。

## 查询规范
- 原则上禁止在业务逻辑中使用join语句查询，需要将此类复杂查询场景转化为多个简单查询场景。
- IN查询，传入参数过多导致无法利用索引，可以拆分IN参数并发查询。多字段IN查询，只按照一个字段拆分。
- 需要所有的在线查询都能够利用到高效的索引。大多数慢查是由于缺乏高效索引导致的，项目初期数据量小，此问题不易暴露。
- 字段查询采取够用原则，每次请求必须明确业务场景需要查询的字段，原则上禁止无脑查询全部字段，禁止SELECT * 查询。
- 已使用高效索引但查询结果集过大（主要是大账户）导致的慢查询，可以考虑添加缓存。
- 分页查询，强烈不建议采用limit分页。非在线场景下，禁止使用limit分页查询，当数据量较大时，容易造成深分页问题，需要使用基于主键id的cursor查询。
- 扫全表场景，禁止一次性查全表数据或使用limit分页。需要使用基于主键id的cursor查询。
- 新增联合索引后，删除最左前缀匹配的冗余索引，保证单表索引数量不超过5个。

## 写入规范
- 批量写入场景，工单、定时任务等，需要有写入速度的限制措施，防止因为写入过快导致主从延迟过高。
- 禁止在事务逻辑中访问外部资源，如RPC调用，Redis访问等。否则会导致锁被长期占用。
- 批量写入拆分，单次更新行数超过1w，造成数据库死锁以及产生超大事务。UPDATE table SET status = 1 WHERE id IN (?) -- 单次传入超过1w个id
